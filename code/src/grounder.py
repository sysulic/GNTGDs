# -*- coding: utf-8 -*-
"""Rule Instantiation."""

from copy import copy, deepcopy
from functools import reduce
from itertools import product

from model import *
from unifier import *

# Instantiation
def instantiated(atom):
	"""Check if atom is instantiated."""
	if atom:
		for term in atom.terms:
			if isinstance(term, Constant):
				pass
			elif isinstance(term, Function):
				return instantiated(term)
			else:
				return False
		return True
	else:
		return False

def instantiate_rule(rule, abox, restricted=None):
	"""Instantiate rule by facts, satisfying certain restrict."""

	def find_guarded_atom(rule):
		"""Find guarded atom of an uninstantiated rule."""
		# try:
		# 	return rule.guard
		# except BaseException:
		# 	max_variable_count = -1
		# 	for atom in rule.body:
		# 		if int(atom) > 0:  # positive
		# 			variable_count = len({term for term in atom.terms if isinstance(term, Variable)})
		# 			if variable_count > max_variable_count:
		# 				max_variable_count = variable_count
		# 				rule.guard = atom
		# 				return atom
		# 	return None
		try:
			return rule.guard
		except BaseException:
			variables = set()
			for atom in rule.body:
				if int(atom) > 0:
					variables.update({term for term in atom.terms if isinstance(term, Variable)})
			for atom in rule.body:
				if int(atom) > 0 and variables.issubset(set(atom.terms)):
					rule.guard = atom
					return atom
			print('Not a GNTGD')
			print(rule)
			exit(-1)

	# filter → Cartessian → unifiers
	body_atom_sets = [  # {...Body Atom1 Instances...}, {...Body Atom2 Instances...}
		filter(lambda x: x and x[0] and (restricted(x[1]) if restricted else True),
			[
				(
					unify_atom(body_atom, fact_atom),
					fact_atom if body_atom is find_guarded_atom(rule) else None
				)
				for fact_atom in abox[body_atom]
			]
		)
		for body_atom in rule.body
	]
	rule_unifiers = filter(
		lambda x: x and x[0],
		[
			(
				merge_unifiers([x[0] for x in unifiers]),
				next(iter(filter(None, [x[1] for x in unifiers])), None)
			)
			for unifiers in product(*body_atom_sets)  # [ (unifier1, None), (unifier2, guard), ]
		]
	)

	# apply unifiers
	instantiated_rules = []
	for rule_unifier, guard in rule_unifiers:
		instantiated_rule = Rule(
			head={apply_unifier(head_atom, rule_unifier) for head_atom in rule.head} - {False},
			body={apply_unifier(body_atom, rule_unifier) for body_atom in rule.body},
			id=rule.id
		)
		if any(map(instantiated, instantiated_rule.head)) and all(map(instantiated, instantiated_rule.body)) and any([atom not in abox for atom in instantiated_rule.head]):
			update_instantiation_info(instantiated_rule, guard)
			instantiated_rules.append(instantiated_rule)

	return instantiated_rules

class Path(list):
	def __str__(self):
		return "{}".format([str(x) for x in self])

class BasicBlock(list):
	def __str__(self):
		return "BasicBlock({})".format([str(x) for x in self])

class PrimeBlock(list):
	def __str__(self):
		return "PrimeBlock({})".format([str(x) for x in self])

# Path
def update_instantiation_info(instantiated_rule, generate_guard_atom):
	"""Attach generation path to newly instantiated rule. Update basic block/prime block."""
	# print("Generated by: {}".format(generate_guard_atom))
	if not getattr(generate_guard_atom, 'path', False):
		generate_guard_atom.buffer = Path()
		generate_guard_atom.path = Path()
		generate_guard_atom.generated_by = Path()
		generate_guard_atom.basic_blocks = Path()
		generate_guard_atom.prime_blocks = Path()
	for head_atom in instantiated_rule.head:
		# inherit
		head_atom.path = copy(generate_guard_atom.path)
		head_atom.buffer = copy(generate_guard_atom.buffer)
		head_atom.generated_by = copy(generate_guard_atom.generated_by)
		head_atom.basic_blocks = copy(generate_guard_atom.basic_blocks)
		head_atom.prime_blocks = copy(generate_guard_atom.prime_blocks)
		# update
		head_atom.buffer.append(instantiated_rule.id)
		head_atom.path.append(instantiated_rule.id)
		head_atom.generated_by.append(generate_guard_atom)
		update_basic_block_info(head_atom)  # next operation only when new basic block detected
		if len(head_atom.basic_blocks) >= 2:
			update_prime_block_info(head_atom)
	return instantiated_rule

# Basic Block Algorithm
def detect_basic_block(path):
	"""Detect basic block from path."""
	for i in range(1, len(path) // 2 + 1):
		if path[(-1*i):] == path[(-1*i)*2:(-1*i)]:
			return path[-1*i:]

def update_basic_block_info(atom):
	"""Update basic block info."""
	new_basic_block = detect_basic_block(atom.buffer)
	if new_basic_block:
		new_basic_block_size = len(new_basic_block)
		if not atom.basic_blocks and not atom.prime_blocks:  # start of 3rd basic block
			atom.basic_blocks.extend([
				BasicBlock(atom.generated_by[-2*new_basic_block_size:-new_basic_block_size]),
				BasicBlock(atom.generated_by[-new_basic_block_size:]),
			])
		else:
			atom.basic_blocks.append(
				BasicBlock(atom.generated_by[-new_basic_block_size:])
			)
		atom.buffer = new_basic_block
	return new_basic_block

# Prime Block Algorithm
def Dom(C):
	"""{Terms} that appear in {Atoms} C."""
	return set.union(*[set(atom.terms) for atom in C])

def isomorphic(dom_c):
	"""Detect if two atoms are Dom(C)-isomorphic."""
	def dom_c_isomorphic(atom_a, atom_b):
		if atom_a.index == atom_b.index:
			unifier = merge_unifiers([
				{term_a: term_b}
				for term_a, term_b in zip(atom_a.terms, atom_b.terms)
				if term_a not in dom_c and term_b not in dom_c
			])
			if unifier:
				return atom_b.terms == [unifier.get(term, term) for term in atom_a.terms]
			else:
				return False
		else:
			return False
	return dom_c_isomorphic

def detect_prime_block(basic_blocks, next_atom):
	"""Detect Prime Block."""
	a_1 = basic_blocks[0][0]
	a_n = basic_blocks[-1][0]
	a_prev_n = basic_blocks[-2][0]
	a_next_n = next_atom
	dom_a_1_isomorphic = isomorphic(Dom({a_1}))
	return dom_a_1_isomorphic(a_n, a_next_n) and not dom_a_1_isomorphic(a_n, a_prev_n)

def update_prime_block_info(atom):
	"""Prime Block Detection Algorithm."""
	if detect_prime_block(atom.basic_blocks, atom):
		atom.prime_blocks.append(copy(atom.basic_blocks))
		atom.basic_blocks = Path()

# Test
if __name__ == '__main__':
	# Rule Instantiation
	from parser import parse_program